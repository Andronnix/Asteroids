<!doctype HTML>
<HTML>
  <script src="processing.js"></script>


  <style>
    body{
      background-color:black;
      color:white;
    }
    input{
      background-color:#42B53E;
      color:#000;
      border-color:#42B53E;
      -webkit-border-radius: 5px;
      -moz-border-radius: 5px;
      border-radius: 5px;
    }
    input:hover{
      border-color:#5DE858;
      color:#EBFF9C;
    }
    input:active{
      background-color:#31872E;
    }
    range{
      -webkit-appearance: slider-vertical;
      width: 20px;
      heigth: 300px;
    }
    .control{
      display:inline;
      vertical-align:top;
    }
    .control input{
      vertical-align:top;
    }
    .off{
      background-color:#42B53E;
    }
    .on{
      background-color:#E6252E;
    }
  </style>
  <body>
  <canvas id="holder"></canvas>
  <script>
  var sky;
  var asteroids;
  var MAXVELOCITY = 10;
  
  var point = function(x, y) {
    this.x = x;
    this.y = y;
    this.isInsideRect = function(minX, minY, maxX, maxY) {
      if (this.x < minX || this.x > maxX || this.y < minY || this.y > maxY) return false;
      return true;
    }

    this.isInsidePoly = function(polyArr) {
      var hit = false;
      for (var i = 0, j = polyArr.length - 1; i < polyArr.length; i++) {
        if ((((polyArr[i].y <= this.y) && (this.y < polyArr[j].y)) || ((polyArr[j].y <= this.y) && (this.y < polyArr[i].y))) && (this.x < (polyArr[j].x - polyArr[i].x) * (this.y - polyArr[i].y) / (polyArr[j].y - polyArr[i].y) + polyArr[i].x))
            hit = !hit;
        j = i;
      }
      return hit;
    }
  }

  var dt = 25;
  var pageSizeH = 550;
  var pageSizeW = 1200;

  function d2h(a) {return a.toString(16);}

  var StarsSky = function(processing, width, height) {
    this.N = 100;
    this.stars = new Array();
    this.processing = processing;
    this.width = width;
    this.height = height;

    var Star = function (x, y, blinkPeriod) {
      this.x = x;
      this.y = y;
      this.blinkPeriod = blinkPeriod;
      this.nextBlink = blinkPeriod;
    }

    this.refillStars = function(){
      var blinkPeriodMax = 10000;
      var blinkPeriodMin = 1000;

      for(var i = 0; i < this.N; i++) {
        if(!this.stars[i]) {
          this.stars[i] = new Star(
            Math.random() * this.width,
            Math.random() * this.height,
            blinkPeriodMin + Math.random() * (blinkPeriodMax - blinkPeriodMin)
          );
        }
      }

    }

    this.draw = function(processing) {
      var s, R;

      for(var i = 0; i < this.N; i++) {
        s = this.stars[i];
        R = 3 * Math.sin(s.nextBlink / s.blinkPeriod * Math.PI * 2);
        processing.ellipse(s.x, s.y, R, R);
      }

    }

    this.update = function(processing) {
      for(var i = 0; i < this.N; i++) {
        this.stars[i].nextBlink -= dt;
        if(this.stars[i].nextBlink <= 0){
          this.stars[i].nextBlink = this.stars[i].blinkPeriod;
        }
      }
      this.refillStars();
      this.draw(processing);
    }

    /*Constructor code */

    var log100 = Math.log(100);
    for(var i = 0; i < this.N; i++) this.stars[i] = null;
    this.refillStars();

  }

  var GenerateAst = function(processing, amount, minR, maxR) {
    asteroids = new Array();
    this.edges = 7; // later will change them... or not :)
    var Asteroid = function(x, y, minR, maxR, edges, dx, dy) {
      this.edges = new Array(); //point() array
      this.x = x;
      this.y = y;
      this.speed = [dx, dy];
      var self = this;

      var delta = maxR - minR;
      var angleStep = Math.PI * 2 / edges;
      var angle = 0;
      for (var i = 0; i < edges; i++) {
        var bone = minR + Math.random() * delta;
        var tx = this.x + bone * Math.cos(angle);
        var ty = this.y + bone * Math.sin(angle);
        this.edges[i] = new point(tx, ty);
        angle += angleStep;
      }
      
      // this will move Asteroid to the specified point with the same acceleration 
      this.relocate = function(newX, newY) {
        var dx = newX - self.x;
        var dy = newY - self.y;
        self.x += dx;
        self.y += dy;

        for (var j = 0; j < self.edges.length; j++) {
          self.edges[j].x += dx;
          self.edges[j].y += dy;
        }
      }

      this.drawCopy = function(sx, sy) {
        processing.stroke("#FFFFFF");
        for (var j = 0, k = self.edges.length - 1; j < self.edges.length; j++) {
          processing.line(self.edges[j].x + sx, self.edges[j].y + sy, self.edges[k].x + sx, self.edges[k].y + sy);
          k = j;
        }
      }

      /* 
       * returns array of three values [sx, sy, out]
       * sx = -1 if this is crossing LEFT border
       * sx = 0  if this not crossing any border
       * sx = 1  if this is crossing RIGHT border
       *
       * sy = -1 if this is crossing TOP border
       * sy = 0  if this not crossing any border
       * sy = 1  if this is crossing BOTTOM border
       *
       * out = false if this intersects page
       * out = true if this has no intersections with page
      */
      this.checkBorder = function() {
        var sx = 0, sy = 0, outX = 0, outY = 0;
        for (var j = 0; j < self.edges.length; j++) {          
          if (this.edges[j].x < 0) {outX++; sx = -1;}
          if (this.edges[j].x >= pageSizeW) {outX++; sx = 1;}
          if (this.edges[j].y < 0) {outY++; sy = -1;}
          if (this.edges[j].y >= pageSizeH) {outY++; sy = 1;}
        }
        return [sx, sy, outX == self.edges.length || outY == self.edges.length];
      }

      this.move = function() {
        this.x += this.speed[0];
        this.y += this.speed[1];
        for (var j = 0; j < this.edges.length; j++) {
          this.edges[j].x += this.speed[0];
          this.edges[j].y += this.speed[1];
        }
      }

      this.draw = function(processing) {
        var out = self.checkBorder();
        self.drawCopy(0, 0);
        if(out[0] * out[0] + out[1] * out[1] > 0) {
          self.drawCopy(-out[0] * pageSizeW, -out[1] * pageSizeH);
        }
      }

      this.update = function(processing) {        
        this.move();

        var out = self.checkBorder();
        if(out[2]) {
          this.relocate((pageSizeW + this.x) % pageSizeW, (pageSizeH + this.y) % pageSizeH);
        }

        self.draw(processing);
      }
    
    /*var absAsteroid = function() {
      this.x = null;
      this.y = null;
      this.edges = null;
      this.speed = [0, 0];
      this.update = null;
      this.move = null;
      this.relocate = null;
      }*/
    }
    for (var i = 0; i < amount; i++) {
      asteroids[i] = new Asteroid(
              Math.random() * pageSizeW, Math.random() * pageSizeH,
              minR, maxR, this.edges,
              MAXVELOCITY - Math.random() * MAXVELOCITY * 2,
              MAXVELOCITY - Math.random() * MAXVELOCITY * 2);
    }
  }

  function sketchProc(processing) {
    processing.setup = function(){
      pageSizeW = window.innerWidth - 1;
      pageSizeH = window.innerHeight - 1;
      canvas.style.position = "absolute";
      canvas.style.top = canvas.style.left = 0;
      processing.size(pageSizeW, pageSizeH);
      processing.strokeWeight(1);
      processing.frameRate(1000 / dt);

      processing.background(0);
      processing.stroke("#FFFFFF");

      sky = new StarsSky(processing, pageSizeW, pageSizeH);
      GenerateAst(processing, 10, 20, 40);
    };
    processing.draw = function(){
      processing.background(0);
      sky.update(processing);
      for (var i = 0; i < asteroids.length; i++)asteroids[i].update(processing);
    }
  }
  var canvas = document.getElementById("holder");

// attaching the sketchProc function to the canvas
  var p = new Processing(canvas, sketchProc);

  </script>

  </body>
</HTML>

