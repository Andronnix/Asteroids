<!doctype HTML>
<HTML>
  <script src="processing.js"></script>


  <style>
    body{
      background-color:black;
      color:white;
    }
    input{
      background-color:#42B53E;
      color:#000;
      border-color:#42B53E;
      -webkit-border-radius: 5px;
      -moz-border-radius: 5px;
      border-radius: 5px;
    }
    input:hover{
      border-color:#5DE858;
      color:#EBFF9C;
    }
    input:active{
      background-color:#31872E;
    }
    range{
      -webkit-appearance: slider-vertical;
      width: 20px;
      heigth: 300px;
    }
    .control{
      display:inline;
      vertical-align:top;
    }
    .control input{
      vertical-align:top;
    }
    .off{
      background-color:#42B53E;
    }
    .on{
      background-color:#E6252E;
    }
  </style>
  <body>
  <canvas id="holder"></canvas>
  <script>
  var sky;
  var asteroids;
  var MAXVELOCITY = 10;
  
  var point = function(x, y) {
    this.x = x;
    this.y = y;
    this.isInsideRect = function(minX, minY, maxX, maxY) {
      if (this.x < minX || this.x > maxX || this.y < minY || this.y > maxY) return false;
      return true;
    }

    this.isInsidePoly = function(polyArr) {
      var hit = false;
      for (var i = 0, j = polyArr.length - 1; i < polyArr.length; i++) {
        if ((((polyArr[i].y <= this.y) && (this.y < polyArr[j].y)) || ((polyArr[j].y <= this.y) && (this.y < polyArr[i].y))) && (this.x < (polyArr[j].x - polyArr[i].x) * (this.y - polyArr[i].y) / (polyArr[j].y - polyArr[i].y) + polyArr[i].x))
            hit = !hit;
        j = i;
      }
      return hit;
    }
  }

  var dt = 25;
  var pageSizeH = 550;
  var pageSizeW = 1200;

  function d2h(a) {return a.toString(16);}

  var StarsSky = function(processing, width, height) {
    this.N = 100;
    this.stars = new Array();
    this.processing = processing;
    this.width = width;
    this.height = height;

    var Star = function (x, y, blinkPeriod) {
      this.x = x;
      this.y = y;
      this.blinkPeriod = blinkPeriod;
      this.nextBlink = blinkPeriod;
    }

    this.refillStars = function(){
      var blinkPeriodMax = 10000;
      var blinkPeriodMin = 1000;

      for(var i = 0; i < this.N; i++) {
        if(!this.stars[i]) {
          this.stars[i] = new Star(
            Math.random() * this.width,
            Math.random() * this.height,
            blinkPeriodMin + Math.random() * (blinkPeriodMax - blinkPeriodMin)
          );
        }
      }

    }

    this.draw = function(processing) {
      var s, R;

      for(var i = 0; i < this.N; i++) {
        s = this.stars[i];
        R = 3 * Math.sin(s.nextBlink / s.blinkPeriod * Math.PI * 2);
        processing.ellipse(s.x, s.y, R, R);
      }

    }

    this.update = function(processing) {
      for(var i = 0; i < this.N; i++) {
        this.stars[i].nextBlink -= dt;
        if(this.stars[i].nextBlink <= 0){
          this.stars[i].nextBlink = this.stars[i].blinkPeriod;
        }
      }
      this.refillStars();
      this.draw(processing);
    }

    /*Constructor code */

    var log100 = Math.log(100);
    for(var i = 0; i < this.N; i++) this.stars[i] = null;
    this.refillStars();

  }

  var GenerateAst = function(processing, amount, minR, maxR) {
    asteroids = new Array();
    this.edges = 7; // later will change them... or not :)
    var Asteroid = function(x, y, minR, maxR, edges, dx, dy) {
      this.edges = new Array(); //point() array
      this.x = x;
      this.y = y;
      this.speed = [dx, dy];
      var delta = maxR - minR;
      var angleStep = Math.PI * 2 / edges;
      var angle = 0;
      for (var i = 0; i < edges; i++) {
        var bone = minR + Math.random() * delta;
        var tx = this.x + bone * Math.cos(angle);
        var ty = this.y + bone * Math.sin(angle);
        this.edges[i] = new point(tx, ty);
        angle += angleStep;
      }
      
      // this will move Asteroid to the specified point with the same acceleration 
      this.relocate = function(newX, newY) {
        var oldSpeed = new Array();
        oldSpeed[0] = this.speed[0];
        oldSpeed[1] = this.speed[1];
        this.speed[0] = newX - this.x;
        this.speed[1] = newY - this.y;
        this.move(true);
        this.speed = oldSpeed;
        }

      this.drawWithCopies = function() {
        for (var j = 0, k = this.edges.length - 1; j < this.edges.length; j++) {
          processing.line(this.edges[j].x, this.edges[j].y, this.edges[k].x, this.edges[k].y);
          processing.line(this.edges[j].x - pageSizeW, this.edges[j].y, this.edges[k].x - pageSizeW, this.edges[k].y);
          processing.line(this.edges[j].x, this.edges[j].y - pageSizeH, this.edges[k].x, this.edges[k].y - pageSizeH);
          processing.line(this.edges[j].x + pageSizeW, this.edges[j].y, this.edges[k].x + pageSizeW, this.edges[k].y);
          processing.line(this.edges[j].x, this.edges[j].y + pageSizeH, this.edges[k].x, this.edges[k].y + pageSizeH);
          k = j;
        }
      }

      this.move = function(skip) {
        skip = skip || false;
        var ranAway = true;
        var ranPartly = false;
        this.x += this.speed[0];
        this.y += this.speed[1];
        for (var j = 0; j < this.edges.length; j++) {
          this.edges[j].x += this.speed[0];
          this.edges[j].y += this.speed[1];
          if (this.edges[j].x < 0 || this.edges[j].x >= pageSizeW ||
                  this.edges[j].y < 0 || this.edges[j].y >= pageSizeH)
            ranPartly = true;
          else
            ranAway = false;
          //hittest
          for (var k = 0; k < asteroids.length; k++){
            if (this.x != asteroids[k].x && this.y != asteroids[k].y && this.edges[j].isInsidePoly(asteroids[k].edges)) {
              this.speed[0] *= -1;
              this.speed[1] *= -1;
            }
          }
        }
        if (ranAway && !skip) {
          this.relocate((pageSizeW + this.x) % pageSizeW, (pageSizeH + this.y) % pageSizeH);
        } else
          if (ranPartly) return false;
        return true;
      }

      this.update = function(processing) {
        processing.stroke("#FFFFFF");
        if (this.move()) {
          for (var j = 0, k = this.edges.length - 1; j < this.edges.length; j++) {
            processing.line(this.edges[j].x, this.edges[j].y, this.edges[k].x, this.edges[k].y);
            k = j;
          }
        } else
          this.drawWithCopies();
      }
      /*this.clone = function() {
        var cl = new Asteroid(this.x, this.y);
      }*/

    for (var i = 0; i < amount; i++) {
      asteroids[i] = new Asteroid(
        Math.random() * pageSizeW, Math.random() * pageSizeH,
        minR, maxR, this.edges,
        MAXVELOCITY - Math.random() * MAXVELOCITY * 2,
        MAXVELOCITY - Math.random() * MAXVELOCITY * 2);
    }
    
    /*var absAsteroid = function() {
      this.x = null;
      this.y = null;
      this.edges = null;
      this.speed = [0, 0];
      this.update = null;
      this.move = null;
      this.relocate = null;
      }*/
    }
  }

  function sketchProc(processing) {
    processing.setup = function(){
      pageSizeW = window.innerWidth - 1;
      pageSizeH = window.innerHeight - 1;
      canvas.style.position = "absolute";
      canvas.style.top = canvas.style.left = 0;
      processing.size(pageSizeW, pageSizeH);
      processing.strokeWeight(1);
      processing.frameRate(1000 / dt);

      processing.background(0);
      processing.stroke("#FFFFFF");

      sky = new StarsSky(processing, pageSizeW, pageSizeH);
      GenerateAst(processing, 5, 20, 40);
    };
    processing.draw = function(){
      processing.background(0);
      sky.update(processing);
      for (var i = 0; i < asteroids.length; i++)asteroids[i].update(processing);
    }
  }
  var canvas = document.getElementById("holder");

// attaching the sketchProc function to the canvas
  var p = new Processing(canvas, sketchProc);

  </script>

  </body>
</HTML>

